# 大厂八股之——乐观锁

## why

数据竞争（ data race）场景中，如果不对待操作的数据做管控，数据的结果是随机的，未知的。

这种问题往往难以复现，事后排查难度大。

加锁是这一问题的解法，锁分为乐观锁和悲观锁，悲观锁是阻塞其他线程或者分布式节点，在读多写少的场景中，读性能存在比较大的问题，为了解决读性能问题，乐观锁就出现了。

## what

乐观锁是先读取，等到需要更新数据的时候，再去判断下是否有其他写入。如果没有其他方写入，这次更新直接成功。否则重试。在读多写少场景能极大改善读性能。

## how

根据场景来看，实现方式叫法不同。

### 微观来看

单机环境中，多线程更新同一个内存位置，解决方案是 cas(compare and swap)

### 宏观来看

分布式节点更新远端 db 中同一个 key。解决方案是fencing token。

实现原理都是一样的。给数据增加一个 version，每次更新时，该 version 会自增。version 的维护可以 db 自带，也可以由第三方维护，一般有个递增生成器就行了。

## 数据更新步骤如下:

第一步，value1,version1 = get(key)
第二步，执行业务逻辑
第三步，set(key,value2,version1)
if version1 == 远端数据 version ，则这次更新成功。否则上面 3 步。