# 从相亲的权衡——看数据库的隔离级别

## 为什么需要 db 支持不同的隔离级别？

真实场景有太多并发带来的data race，解决方案就是加锁，但每次都加锁性能差，为了解决性能问题，需要对锁细化，本质是性能和体验的权衡。而权衡是一门艺术，有两个女孩追求小王，一个女孩很有钱，一个女孩很漂亮，小王最终选择了胸大的。

## 并发会带来什么问题？

### 1  脏读

 a 事务可以读取到b 事务中还未提交的值。发生条件是，a 和 b 事务都修改同一行， 两个事务都还未提交。

### 2  脏写

 a 和 b 事务都修改同一行，两个事务都还未提交， a 事务可以覆盖 b 事务已经写入的值。

### 3 不可重复读

 a 在事务期间两次读取同一个值，两次读取到的值不同。发生条件如下：

- t0 a 第一次读取时，b 还未开始，
- t1 a 第二次读取时，b 已经提交。

### 4 幻读

 a 事务两次读取范围时，返回的值不一样。发生条件如下：

- t0 a 第一次读取范围
- t1  b 在这个范围内插入新记录
- t2 a 第二次读取范围

### 5 更新丢失

 假设 a 的账户余额是 100 元，a 同时发起两次转账。发生条件如下：

- t1 第一次转 1 元，网络原因还未完成。余额还未更新。
- t2 进行第二次转账转 90 元，这次立马就成功了，账户余额更新为 10 元。
- t3 第一次转账成功，余额更新为 99 元。

## 隔离级别如何解决这些问题？

### 1  读未提交

 这就不说了，上面都存在。

### 2  读已提交级别

 解决脏读和脏写问题。实现如下：在事务开始时，会记住待修改的已提交值，防止脏读。在修改行时对该行上锁，防止脏写。

### 3  可重复读（也叫快照隔离）

 解决脏读，脏写，不可重复读。实现如下：通过写锁防止冲突写，通过 mvcc 保持 db 数据多版本（快照），从而实现事务期无锁的重复读，都会读取到同样版本的值。

### 4  串行化

 解决解决单机事务的所有并发问题。每次转账必须有确定结果才能进行下次转账。性能差但最稳，稳如老狗。杜绝一切并发。（但也不是银弹，分区的事务就解决不了，分区事务就会依赖臭名昭著的两阶段提交）

大都数据库采用可重复读级别，面试中非常喜欢问 next-key lock 是什么，它是由mvcc （读多版本，写行锁）和 gap lock 组合的，是 mysql 在可重复读级别下，解决幻读问题的实现。