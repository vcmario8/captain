# 服务端面试体系——缓存

10个人面试，9个人讲缓存。

架构师是如何思考缓存技术的？速度快的介质成本高/容量小，用于存储价值高的数据；速度慢的介质成本低/容量大，适合放全量数据。古早时期操作系统在管理cpu缓存和内存时，就有了成熟的缓存技术；存储引擎中也大量采用这些技术；互联网应用系统中也大量使用这种技术。缓存技术原理都是一样的，打好基础很重要。

## 缓存三板斧：构建、更新、淘汰

### 1）构建

常见于扩容、上线；一般通过预热来解决，读时预热，但收敛慢，而且请求会洞穿到DB；从其他副本中预热，实现上会比较复杂，但缓存构建速度快，很多存储系统都采用这种方式。

### 2）更新

按更新方式有三种分类：

- Cache aside：调用方负责更新缓存；读取时，先从cache 取数据，命中后直接返回，miss后回源db，再构建缓存；更新数据时，调用方先更新db再更新缓存；调用方非常麻烦，一般可以通过 sdk 封装这个逻辑；大部分带 sdk 的存储系统都是采用这种方式。
- Read/write through：缓存系统本身负责更新缓存；两者区别在于更新缓存时机；读数据时回源db更新缓存叫read through； 数据更新时，先写回源 db 再更新缓存叫write through；大部分互联网业务采用这种方式。
- Write back：数据更新时只更新缓存，后续异步更新主存；这种模式如果掉电会丢数据；操作系统中，L1/L2/L3/mem/disk几个存储间的一致性都是采用这种技术，比如 L1/2/3和mem数据一致性；大部分游戏服务器也是采用这种方式，游戏服务器大部分操作都在本地进程进行，定时write back回db。

很多基于日志存储系统，更新数据先追加写日志，然后更新内存缓存后就返回了；缓存会定时write back 到磁盘；掉电后会丢失未持久化到 db 的数据，因此恢复数据需要从最近的write back 点开始重放数据，比如mysql中的checkpoint就是这个原理。

### 3）淘汰

有LRU/single fly等技术，有些面试官还会考察非法key，给缓存简单加个LRU 策略就行了。

多说点，更新缓存有多步操作，本质上依旧存在data  race 问题，这几种套路都可以极大降低不一致的概率，但依旧有不一致的风险；金融等要求强一致的场景，2pc/3pc才是解决方案。