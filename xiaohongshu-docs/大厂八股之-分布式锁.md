# 大厂八股之——分布式锁

## why

秒杀场景下，多个节点对库存的扣减操作，容易超卖。

跨节点进程对数据同时更新时，会导致结果不确定。

本质上是所有data race 的场景下，对数据的更新要做保护。

这些场景的解决方案，一般是加锁串行化。

## what

锁是多个进程（含跨节点）串行化的解决方案，持有锁的进程才能更新资源。持有者做完操作后，要释放锁。因此分布式锁的使用流程是：检测锁，加锁，释放锁。最后要锁超时释放，避免死锁。

## how

使用流程上有两个关注点：1） 检测锁和加锁，是两个 io 操作，数据并发场景下，必须保障原子性。2）释放锁仅能释放自己的持有锁。

## 工程实现

### 1 mysql

就是利用 select for update 的行锁实现，适用于并发小的场景。

### 2 redis

利用 setnx 保障检测和添加的原子性，利用 lua 脚本判断是不是本进程持有，再删除锁。同时给 key 设定过期时间。适用于 qps 10w 级别的场景。再大的 qps 要考虑拆分，分治了。

### 3 zookeeper 场景

所有节点访问同一个目录，获得的序号递增，序号最小者获得锁，同时监听比自己序号小的节点，等锁释放后会回调通知。适用于 qps小千级别的场景。

## 可靠性

主库挂了，怎么办？主库单点问题是隐患。

zk 的实现不存在这个问题。

mysql 实现，可以配置从库全同步方式，主库挂了做好主从切换（分布式场景下如何判断主挂了是有挑战的，比如主库未响应可能是网络超时，因此往往要多次探测，同时换不同节点探测，而且探测的节点也有单点问题，因此往往需要人工介入判断）。

redis 实现，主从是通过存量传输 rdb 和异步同步增量指令的方式，存在延迟。主从切换同样面临挑战。

关于 redis 实现可靠性问题，官方作者给的解法是 redlock，本质上是 quorumn刷盘机制，比如 n=3,r=2,w=2。能容忍半数的故障，但也会带来折损。

ddia 作者怼过这个方案，他认为 应该利用 fencing token 机制是解决这类问题，就是 cas。给数据增加一个版本号，版本低的不能对比版本高的